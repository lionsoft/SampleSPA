interface Array<T> {
    constructor(getEnumerator: () => linqjs.IEnumerator<T>);
    getEnumerator(): linqjs.IEnumerator<T>;

    // Extension Methods
    traverseBreadthFirst(func: (element: T) => linqjs.IEnumerable<T>): linqjs.IEnumerable<T>;
    traverseBreadthFirst<TResult>(func: (element: T) => linqjs.IEnumerable<T>, resultSelector: (element: T, nestLevel: number) => TResult): linqjs.IEnumerable<TResult>;
    traverseDepthFirst<TResult>(func: (element: T) => linqjs.Enumerable): linqjs.IEnumerable<T>;
    traverseDepthFirst<TResult>(func: (element: T) => linqjs.Enumerable, resultSelector?: (element: T, nestLevel: number) => TResult): linqjs.IEnumerable<TResult>;
    flatten(): linqjs.IEnumerable<any>;
    pairwise<TResult>(selector: (prev: T, current: T) => TResult): linqjs.IEnumerable<TResult>;
    scan(func: (prev: T, current: T) => T): linqjs.IEnumerable<T>;
    scan<TAccumulate>(seed: TAccumulate, func: (prev: TAccumulate, current: T) => TAccumulate): linqjs.IEnumerable<TAccumulate>;
    select<TResult>(selector: (element: T, index: number) => TResult): linqjs.IEnumerable<TResult>;
    selectMany<TOther>(collectionSelector: (element: T, index: number) => linqjs.IEnumerable<TOther>): linqjs.IEnumerable<TOther>;
    selectMany<TCollection, TResult>(collectionSelector: (element: T, index: number) => linqjs.IEnumerable<TCollection>, resultSelector: (outer: T, inner: TCollection) => TResult): linqjs.IEnumerable<TResult>;
    selectMany<TOther>(collectionSelector: (element: T, index: number) => TOther[]): linqjs.IEnumerable<TOther>;
    selectMany<TCollection, TResult>(collectionSelector: (element: T, index: number) => TCollection[], resultSelector: (outer: T, inner: TCollection) => TResult): linqjs.IEnumerable<TResult>;
    selectMany<TOther>(collectionSelector: (element: T, index: number) => { length: number;[x: number]: TOther; }): linqjs.IEnumerable<TOther>;
    selectMany<TCollection, TResult>(collectionSelector: (element: T, index: number) => { length: number;[x: number]: TCollection; }, resultSelector: (outer: T, inner: TCollection) => TResult): linqjs.IEnumerable<TResult>;
    where(predicate: (element: T, index: number) => boolean): linqjs.IEnumerable<T>;
    choose(selector: (element: T, index: number) => T): linqjs.IEnumerable<T>;
    ofType<TResult>(type: any): linqjs.IEnumerable<TResult>;
    zip<TResult>(second: linqjs.IEnumerable<T>, resultSelector: (first: T, second: T, index: number) => TResult): linqjs.IEnumerable<TResult>;
    zip<TResult>(second: { length: number;[x: number]: T; }, resultSelector: (first: T, second: T, index: number) => TResult): linqjs.IEnumerable<TResult>;
    zip<TResult>(second: T[], resultSelector: (first: T, second: T, index: number) => TResult): linqjs.IEnumerable<TResult>;
    zip<TResult>(...params: any[]): linqjs.IEnumerable<TResult>; // last one is selector
    merge<TResult>(...params: linqjs.IEnumerable<T>[]): linqjs.IEnumerable<T>;
    merge<TResult>(...params: { length: number;[x: number]: T; }[]): linqjs.IEnumerable<T>;
    merge<TResult>(...params: T[][]): linqjs.IEnumerable<T>;
    join<TInner, TKey, TResult>(inner: linqjs.IEnumerable<TInner>, outerKeySelector: (outer: T) => TKey, innerKeySelector: (inner: TInner) => TKey, resultSelector: (outer: T, inner: TKey) => TResult, compareSelector?: (obj: T) => TKey): linqjs.IEnumerable<TResult>;
    join<TInner, TKey, TResult>(inner: { length: number;[x: number]: TInner; }, outerKeySelector: (outer: T) => TKey, innerKeySelector: (inner: TInner) => TKey, resultSelector: (outer: T, inner: TKey) => TResult, compareSelector?: (obj: T) => TKey): linqjs.IEnumerable<TResult>;
    join<TInner, TKey, TResult>(inner: TInner[], outerKeySelector: (outer: T) => TKey, innerKeySelector: (inner: TInner) => TKey, resultSelector: (outer: T, inner: TKey) => TResult, compareSelector?: (obj: T) => TKey): linqjs.IEnumerable<TResult>;
    groupJoin<TInner, TKey, TResult>(inner: linqjs.IEnumerable<TInner>, outerKeySelector: (outer: T) => TKey, innerKeySelector: (inner: TInner) => TKey, resultSelector: (outer: T, inner: TKey) => TResult, compareSelector?: (obj: T) => TKey): linqjs.IEnumerable<TResult>;
    groupJoin<TInner, TKey, TResult>(inner: { length: number;[x: number]: TInner; }, outerKeySelector: (outer: T) => TKey, innerKeySelector: (inner: TInner) => TKey, resultSelector: (outer: T, inner: TKey) => TResult, compareSelector?: (obj: T) => TKey): linqjs.IEnumerable<TResult>;
    groupJoin<TInner, TKey, TResult>(inner: TInner[], outerKeySelector: (outer: T) => TKey, innerKeySelector: (inner: TInner) => TKey, resultSelector: (outer: T, inner: TKey) => TResult, compareSelector?: (obj: T) => TKey): linqjs.IEnumerable<TResult>;
    all(predicate: (element: T) => boolean): boolean;
    any(predicate?: (element: T) => boolean): boolean;
    isEmpty(): boolean;
    concat(...sequences: linqjs.IEnumerable<T>[]): linqjs.IEnumerable<T>;
    concat(...sequences: { length: number;[x: number]: T; }[]): linqjs.IEnumerable<T>;
    concat(...sequences: T[]): linqjs.IEnumerable<T>;
    insert(index: number, second: linqjs.IEnumerable<T>): linqjs.IEnumerable<T>;
    insert(index: number, second: { length: number;[x: number]: T; }): linqjs.IEnumerable<T>;
    alternate(alternateValue: T): linqjs.IEnumerable<T>;
    alternate(alternateSequence: { length: number;[x: number]: T; }): linqjs.IEnumerable<T>;
    alternate(alternateSequence: linqjs.IEnumerable<T>): linqjs.IEnumerable<T>;
    alternate(alternateSequence: T[]): linqjs.IEnumerable<T>;
    contains(value: T): boolean;
    contains<TCompare>(value: T, compareSelector?: (element: T) => TCompare): boolean;
    defaultIfEmpty(defaultValue?: T): linqjs.IEnumerable<T>;
    distinct(): linqjs.IEnumerable<T>;
    distinct<TCompare>(compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    distinctUntilChanged(): linqjs.IEnumerable<T>;
    distinctUntilChanged<TCompare>(compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    except(second: { length: number;[x: number]: T; }): linqjs.IEnumerable<T>;
    except<TCompare>(second: { length: number;[x: number]: T; }, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    except(second: linqjs.IEnumerable<T>): linqjs.IEnumerable<T>;
    except<TCompare>(second: linqjs.IEnumerable<T>, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    except(second: T[]): linqjs.IEnumerable<T>;
    except<TCompare>(second: T[], compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    intersect(second: { length: number;[x: number]: T; }): linqjs.IEnumerable<T>;
    intersect<TCompare>(second: { length: number;[x: number]: T; }, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    intersect(second: linqjs.IEnumerable<T>): linqjs.IEnumerable<T>;
    intersect<TCompare>(second: linqjs.IEnumerable<T>, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    intersect(second: T[]): linqjs.IEnumerable<T>;
    intersect<TCompare>(second: T[], compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    union(second: { length: number;[x: number]: T; }): linqjs.IEnumerable<T>;
    union<TCompare>(second: { length: number;[x: number]: T; }, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    union(second: linqjs.IEnumerable<T>): linqjs.IEnumerable<T>;
    union<TCompare>(second: linqjs.IEnumerable<T>, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    union(second: T[]): linqjs.IEnumerable<T>;
    union<TCompare>(second: T[], compareSelector: (element: T) => TCompare): linqjs.IEnumerable<T>;
    sequenceEqual(second: { length: number;[x: number]: T; }): boolean;
    sequenceEqual<TCompare>(second: { length: number;[x: number]: T; }, compareSelector: (element: T) => TCompare): boolean;
    sequenceEqual(second: linqjs.IEnumerable<T>): boolean;
    sequenceEqual<TCompare>(second: linqjs.IEnumerable<T>, compareSelector: (element: T) => TCompare): boolean;
    sequenceEqual(second: T[]): boolean;
    sequenceEqual<TCompare>(second: T[], compareSelector: (element: T) => TCompare): boolean;
    orderBy<TKey>(keySelector: (element: T) => TKey): linqjs.IOrderedEnumerable<T>;
    orderByDescending<TKey>(keySelector: (element: T) => TKey): linqjs.IOrderedEnumerable<T>;
    reverse(): linqjs.IEnumerable<T>;
    shuffle(): linqjs.IEnumerable<T>;
    weightedSample(weightSelector: (element: T) => number): linqjs.IEnumerable<T>;
    // truly, return type is linqjs.IEnumerable<IGrouping<TKey, T>> but Visual Studio + TypeScript Compiler can't compile.
    groupBy<TKey>(keySelector: (element: T) => TKey): linqjs.IEnumerable<linqjs.IGrouping<TKey, any>>;
    groupBy<TKey, TElement>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement): linqjs.IEnumerable<linqjs.IGrouping<TKey, TElement>>;
    groupBy<TKey, TElement, TResult>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement, resultSelector: (key: TKey, element: linqjs.IEnumerable<TElement>) => TResult): linqjs.IEnumerable<TResult>;
    groupBy<TKey, TElement, TResult, TCompare>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement, resultSelector: (key: TKey, element: linqjs.IEnumerable<TElement>) => TResult, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<TResult>;
    // :linqjs.IEnumerable<IGrouping<TKey, T>>
    partitionBy<TKey>(keySelector: (element: T) => TKey): linqjs.IEnumerable<linqjs.IGrouping<TKey, any>>;
    // :linqjs.IEnumerable<IGrouping<TKey, TElement>>
    partitionBy<TKey, TElement>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement): linqjs.IEnumerable<linqjs.IGrouping<TKey, TElement>>;
    partitionBy<TKey, TElement, TResult>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement, resultSelector: (key: TKey, element: linqjs.IEnumerable<TElement>) => TResult): linqjs.IEnumerable<TResult>;
    partitionBy<TKey, TElement, TResult, TCompare>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement, resultSelector: (key: TKey, element: linqjs.IEnumerable<TElement>) => TResult, compareSelector: (element: T) => TCompare): linqjs.IEnumerable<TResult>;
    buffer(count: number): linqjs.IEnumerable<T>;
    aggregate(func: (prev: T, current: T) => T): T;
    aggregate<TAccumulate>(seed: TAccumulate, func: (prev: TAccumulate, current: T) => TAccumulate): TAccumulate;
    aggregate<TAccumulate, TResult>(seed: TAccumulate, func: (prev: TAccumulate, current: T) => TAccumulate, resultSelector: (last: TAccumulate) => TResult): TResult;
    average(selector?: (element: T) => number): number;
    count(predicate?: (element: T, index: number) => boolean): number;
    max(selector?: (element: T) => number): number;
    min(selector?: (element: T) => number): number;
    maxBy<TKey>(keySelector: (element: T) => TKey): T;
    minBy<TKey>(keySelector: (element: T) => TKey): T;
    sum(selector?: (element: T) => number): number;
    elementAt(index: number): T;
    elementAtOrDefault(index: number, defaultValue?: T): T;
    first(predicate?: (element: T, index: number) => boolean): T;
    firstOrDefault(predicate?: (element: T, index: number) => boolean, defaultValue?: T): T;
    last(predicate?: (element: T, index: number) => boolean): T;
    lastOrDefault(predicate?: (element: T, index: number) => boolean, defaultValue?: T): T;
    single(predicate?: (element: T, index: number) => boolean): T;
    singleOrDefault(predicate?: (element: T, index: number) => boolean, defaultValue?: T): T;
    skip(count: number): linqjs.IEnumerable<T>;
    skipWhile(predicate: (element: T, index: number) => boolean): linqjs.IEnumerable<T>;
    take(count: number): linqjs.IEnumerable<T>;
    takeWhile(predicate: (element: T, index: number) => boolean): linqjs.IEnumerable<T>;
    takeExceptLast(count?: number): linqjs.IEnumerable<T>;
    takeFromLast(count: number): linqjs.IEnumerable<T>;
    indexOf(item: T): number;
    indexOf(predicate: (element: T, index: number) => boolean): number;
    lastIndexOf(item: T): number;
    lastIndexOf(predicate: (element: T, index: number) => boolean): number;
    asEnumerable(): linqjs.IEnumerable<T>;
    cast<TResult>(): linqjs.IEnumerable<TResult>;
    toArray(): T[];
    // truly, return type is ILookup<TKey, T> but Visual Studio + TypeScript Compiler can't compile. 
    toLookup<TKey>(keySelector: (element: T) => TKey): linqjs.ILookup<TKey, any>;
    toLookup<TKey, TElement>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement): linqjs.ILookup<TKey, TElement>;
    toLookup<TKey, TElement, TCompare>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TElement, compareSelector: (key: TKey) => TCompare): linqjs.ILookup<TKey, TElement>;
    toObject(keySelector: (element: T) => any, elementSelector?: (element: T) => any): Object;
    // :IDictionary<TKey, T>
    toDictionary<TKey>(keySelector: (element: T) => TKey): linqjs.IDictionary<TKey, any>;
    toDictionary<TKey, TValue>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TValue): linqjs.IDictionary<TKey, TValue>;
    toDictionary<TKey, TValue, TCompare>(keySelector: (element: T) => TKey, elementSelector: (element: T) => TValue, compareSelector: (key: TKey) => TCompare): linqjs.IDictionary<TKey, TValue>;
    toJSONString(replacer: (key: string, value: any) => any): string;
    toJSONString(replacer: any[]): string;
    toJSONString(replacer: (key: string, value: any) => any, space: any): string;
    toJSONString(replacer: any[], space: any): string;
    toJoinedString(separator?: string): string;
    toJoinedString<TResult>(separator: string, selector: (element: T, index: number) => TResult): string;
    doAction(action: (element: T, index: number) => void): linqjs.IEnumerable<T>;
    doAction(action: (element: T, index: number) => boolean): linqjs.IEnumerable<T>;
    forEach(action: (element: T, index: number) => void): void;
    forEach(action: (element: T, index: number) => boolean): void;
    write(separator?: string): void;
    write<TResult>(separator: string, selector: (element: T) => TResult): void;
    writeLine(): void;
    writeLine<TResult>(selector: (element: T) => TResult): void;
    force(): void;
    letBind<TResult>(func: (source: linqjs.IEnumerable<T>) => { length: number;[x: number]: TResult; }): linqjs.IEnumerable<TResult>;
    letBind<TResult>(func: (source: linqjs.IEnumerable<T>) => TResult[]): linqjs.IEnumerable<TResult>;
    letBind<TResult>(func: (source: linqjs.IEnumerable<T>) => linqjs.IEnumerable<TResult>): linqjs.IEnumerable<TResult>;
    share(): linqjs.IDisposableEnumerable<T>;
    memoize(): linqjs.IDisposableEnumerable<T>;
    catchError(handler: (exception: any) => void): linqjs.IEnumerable<T>;
    finallyAction(finallyAction: () => void): linqjs.IEnumerable<T>;
    log(): linqjs.IEnumerable<T>;
    log<TValue>(selector: (element: T) => TValue): linqjs.IEnumerable<T>;
    trace(message?: string): linqjs.IEnumerable<T>;
    trace<TValue>(message: string, selector: (element: T) => TValue): linqjs.IEnumerable<T>;
}
